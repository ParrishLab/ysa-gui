#!/bin/zsh
#
# Secure self-decrypting archive
# This script is designed to safely decrypt its own contents
# 
# Usage: ./filename.senc
#

# Verify we're running on macOS or Linux
if [[ "$(uname)" != "Darwin" && "$(uname)" != "Linux" ]]; then
    echo "This script requires macOS or Linux"
    exit 1
fi

# Verify openssl is available
if ! command -v openssl > /dev/null; then
    echo "Error: openssl command not found"
    exit 1
fi

# Find the line number where the encrypted data begins
SCRIPT_END=$(awk '/^__ENCRYPTED_DATA_BELOW__/ { print NR; exit 0; }' "$0")

if [[ -z "$SCRIPT_END" ]]; then
    echo "Error: Invalid archive format"
    exit 1
fi

# Create a secure temporary directory
if command -v mktemp > /dev/null; then
    TEMP_DIR=$(mktemp -d)
else
    echo "Error: mktemp command not found"
    exit 1
fi

cleanup() {
    rm -rf "$TEMP_DIR"
}
trap cleanup EXIT

# Extract the encrypted data
tail -n +$((SCRIPT_END + 1)) "$0" > "$TEMP_DIR/data.enc"

# Decrypt all content at once to a temporary file
DECRYPTED_FILE="$TEMP_DIR/decrypted_data"
if ! openssl enc -d -aes-256-cbc -pbkdf2 -in "$TEMP_DIR/data.enc" -out "$DECRYPTED_FILE"; then
    echo "Error: Decryption failed - incorrect password?"
    exit 1
fi

# Get the original filename from the first line and combine with current directory
ORIGINAL_NAME=$(head -n 1 "$DECRYPTED_FILE")
OUTPUT_PATH="$(dirname "$0")/$ORIGINAL_NAME"
echo "Decrypting to: $OUTPUT_PATH"

# Extract the actual content (everything after the first line)
tail -n +2 "$DECRYPTED_FILE" > "$OUTPUT_PATH"

if [[ $? -eq 0 && -s "$OUTPUT_PATH" ]]; then
    echo "File successfully decrypted"
    exit 0
else
    echo "Error: Decryption failed"
    [[ -f "$OUTPUT_PATH" ]] && rm "$OUTPUT_PATH"
    exit 1
fi

__ENCRYPTED_DATA_BELOW__
Salted__E‰Œ+C”ƒö·óæóÌ`Æ`Gµýžd§¦xy+Š©+g_Û&X.K